{"title":"数据结构之线性表 List","slug":"数据结构之线性表List","date":"2020-04-20","updated":"2020-04-23","comments":true,"path":"api/posts/6004.json","excerpt":"<p> 线性表（List），了解线性表的基础知识，认识一下线性表的种类。</p>","cover":"/gallery/data-structure-linked-list-normal.png","covers":["/gallery/data-structure-linked-list-normal.png"],"content":"<p>线性表（List），了解线性表的基础知识，认识一下线性表的种类。</p><a id=\"more\"></a><h1 id=\"线性表 List\"><a class=\"headerlink\" href=\"# 线性表 List\"></a>线性表 List</h1><p>线性表（List）：由另个或多个元素组成的有限序列。<strong>元素是有序的，可以被排列的 </strong>。在有序结构中，某个元素<code>ai</code> 前面的元素 <code>ai-1</code> 称为 <strong> 前驱元素 </strong>，后面的元素<code>ai+1</code> 称为 <strong> 后继元素 </strong>。在 Java 语言中，数组（ArrayList）和链表（Linked List）都属于线性表。其中数组使用了顺序结构，而链表使用了链式结构。</p><p> 线性表的数据对象集合为 <code>{a1,a2,...,an-1,an}</code>，每个元素的类型均为<code>DataType</code>。** 数据元素之间的关系是一对一的关系。** 其中，除第一个元素<code>a1</code> 外，每个元素有且只有一个直接前驱元素，除最后一个元素 <code>an</code> 外，每个元素有且只有一个直接后继元素。</p><h1 id=\"线性表伪代码\"><a class=\"headerlink\" href=\"# 线性表伪代码\"></a>线性表伪代码 </h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADT 线性表（List）</span><br><span class=\"line\">Data</span><br><span class=\"line\">  数据对象集合 &#123;a1,a2,...,an-1,an&#125;</span><br><span class=\"line\">Operation</span><br><span class=\"line\">  init(*L)：初始化空线性表 L</span><br><span class=\"line\">  isEmpty(L)：判断线性表是否为空</span><br><span class=\"line\">  clear(*L)：清空线性表</span><br><span class=\"line\">  getElement(L,i,*e)：将线性表 L 中第 i 个元素返回给 e</span><br><span class=\"line\">  elementAt(L,e)：线性表 L 中查找与 e 相等的元素，返回元素的位置</span><br><span class=\"line\">  insert(*L,i,e)：线性表 L 中第 i 个位置插入新元素 e</span><br><span class=\"line\">  delete(*L,i,*e)：删除线性表 L 中第 i 个位置元素，并返回该元素给 e</span><br><span class=\"line\">  length(L)：返回线性表 L 的元数个数</span><br><span class=\"line\">endADT</span><br></pre></td></tr></table></figure><h1 id=\"线性表的顺序存储结构\"><a class=\"headerlink\" href=\"# 线性表的顺序存储结构\"></a> 线性表的顺序存储结构 </h1><p> 线性表的顺序存储结构封装需要 3 个属性：</p><ul><li>存储空间初始位置，数组指针 </li><li> 线性表的最大长度，指存储空间总长度，初始化后不变 </li><li> 线性表的当前长度，指表中元素数量，大于等于 0，小于表的最大长度 </li></ul><h2 id=\"顺序存储结构的地址计算方法\"><a class=\"headerlink\" href=\"# 顺序存储结构的地址计算方法\"></a> 顺序存储结构的地址计算方法 </h2><p><strong> 注：<code>i</code>从“1”开始 </strong></p><p> 假设每个元素类型的 <code>DataType</code> 都需要占用 <code>c</code> 个储存单位（字节），那么线性表中第 <code>i+1</code> 个元素和第 <code>i</code> 个元素的存储位置的关系是（LOC 为获得存储位置的函数）：</p><p><code>LOC(ai+1) = LOC(ai) + c</code></p><p>所以找第 <code>i</code> 个元素 <code>ai</code> 的储存位置可以又线性表初始指针指向的 <code>a1</code> 推算出：</p><p><strong><code>LOC(ai) = LOC(a1) + (i-1) * c</code></strong></p><p>通过这个公式，计算出线性表中任意位置的地址，所用的时间都是相同的，那么他的存储时间性能就是 <code>O(1)</code>，<strong> 这种结构通常被称为随机存储结构。</strong></p><h1 id=\"线性表的链式存储结构\"><a class=\"headerlink\" href=\"# 线性表的链式存储结构\"></a>线性表的链式存储结构 </h1><p> 顺序存储结构最大的缺点，插入和删除需要移动大量元素，从而保持表中元素邻居的关系；链式存储结构通过携带后继元素的存储地址就解决了这个缺点。</p><p>链式存储结构的线性表中元素称为“存储映像”，也称为“节点（Node）”。每个节点都是由两部分组成：</p><ul><li>数据域：储存数据元素信息的域 </li><li> 指针域：存储直接后继元素地址的域 </li></ul><h2 id=\"单链表\"><a class=\"headerlink\" href=\"# 单链表\"></a> 单链表 </h2><p><code>n</code> 个节点链接成一个链表，即为线性表 <code>(a1,a2,...,an-1,an)</code> 的链式存储结构。因为此链表的每个节点中只包含一个指针域，所以叫做单链表。</p><p><img src=\"/gallery/data-structure-linked-list-normal.png\" alt=\"单链表图示\"></p><p>单链表必须有一个头部加上 0 到多个节点。头指针是链表指向第一个节点的指针，如果链表有头结点，则头指针指向头结点。头结点携带第一个元素的节点指针，放在第一个节点之前，其数据域一般无意义，但也可以存放链表的长度。头结点不是必须的，但是头结点可以放一些对列表有用的变量。</p><p>尾指针是指向单链表的最后一个节点的指针，这个指针不是必须的，但是尾指针有好处，比如需要在尾部插入新节点。</p><p><strong>若线性表需要频繁查找，很少进行插入和删除操作是，宜采用顺序存储结构。</strong></p><p><strong>若需要频繁插入和删除时，宜采用单链表结构。</strong></p><h2 id=\"静态链表\"><a class=\"headerlink\" href=\"# 静态链表\"></a>静态链表 </h2><p> 在内存中建立一个数组，在数组最大长度内的空间中再建立一个链表，这种链表就是静态链表。静态链表通过“游标（Cursor）”指向后继元素所处数组中的“下标（Index）”。下图为静态链表转普通链表，最大长度为 <code>100</code>，第一个元素游标指向备用链表的头节点（既当前链表尾节点的游标，也是尾指针），最后一个元素游标指向当前链表头节点。</p><p><img src=\"/gallery/data-structure-linked-list-static-to-normal.png\" alt=\"静态链表转普通链表\"></p><ul><li> 数组中第一个和最后一个元素不存放数据 </li><li> 未使用的数组元素被称为备用链表 </li><li> 数组第一个元素，即 <code>Index = 0</code> 的元素的游标（Cursor）存放备用链表的第一个节点的下标 </li><li> 数组最后一个元素，即 <code>Index = MAX_SIZE-1</code> 的元素的游标（Cursor）存放当前链表的第一个节点的下标 </li><li> 静态链表初始化时，<code>Index = 0</code>的元素的游标应从 <code>1</code> 开始，而 <code>Index = MAX_SIZE-1</code> 的元素的游标则是 <code>0</code>，表示空链表</li></ul><h2 id=\"循环链表\"><a class=\"headerlink\" href=\"# 循环链表\"></a> 循环链表 </h2><p> 在单链表中，如果不从头结点出发，就无法访问到全部节点。循环链表就解决了这个问题。只要有链表中某一节点的指针，就能跑完全部节点。当表为空时，头部后继指针指向头部本身。</p><p><strong>循环链表所用的方法就是把尾节点的空指针指向头节点，使单链表形成一个环，这种头尾相接的单链表被称为单循环链表，简称循环链表。</strong></p><p>原单链表判断尾节点用 <code>node.next === null ?</code>，现在则是用<code>node.next === head ?</code>。</p><h2 id=\"双向链表\"><a class=\"headerlink\" href=\"# 双向链表\"></a> 双向链表 </h2><p> 对比单链表，双向链表的节点有两个指针：前驱指针和后继指针。双向列表允许从尾部往回跑。当表为空时，头部前驱指针和后继指针都指向头部本身。</p><h1 id=\"找单链表中间的节点的方法\"><a class=\"headerlink\" href=\"# 找单链表中间的节点的方法\"></a>找单链表中间的节点的方法 </h1><p> 利用快慢指针原理：设置两个指针 <code>*search</code> 和<code>*middle</code>都指向单链表的头结点。其中 <code>*search</code> 的移动速度是 <code>*middle</code> 的 2 倍。当 <code>*search</code> 指向尾节点时，<code>*middle</code>正好就在中间。</p><p>在一个长度为 100 的单链表中，当 <code>*search</code> 指向第 100 个节点时，<code>*middle</code>指向第 50 个节点。</p><p>在一个长度为 101 的单链表中，当 <code>*search</code> 指向 102（即超出长度）时，<code>*middle</code>指向第 51 个节点，正好在中间。</p><h1 id=\"判断一个链表是否有环\"><a class=\"headerlink\" href=\"# 判断一个链表是否有环\"></a>判断一个链表是否有环 </h1><p> 方法一：设置两个指针 <code>*q</code> 和<code>*b</code>。<code>*q</code>一直在走的情况下，每遇到一个节点，<code>*b</code>就从新从头结点开始走。如果 <code>*q</code> 所在当前步数等于 <code>*b</code> 从头开始数的步数，则 <code>*q</code> 继续往前走一步，而 <code>*b</code> 从新走。如果 <code>*q</code> 所在当前步数不等于 <code>*b</code> 的从头开始数的步数，则存在环。这种方法可以找到环所在节点。</p><p>方法二：设置两个指针 <code>*q</code> 和<code>*b</code>都指向单链表的头结点。其中 <code>*q</code> 的移动速度是 <code>*b</code> 的 2 倍，若在某个时候 <code>*q == *b</code>，则存在环。一般偶数量节点的单循环链表跑两次后<code>*q == *b</code>。</p><blockquote><p> 本文参考：<br><a href=\"https://www.bilibili.com/video/BV1jW411K7yg\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">【C 语言描述】《数据结构和算法》（小甲鱼）</a></p></blockquote>","url":"/posts/6004/","min2read":6,"word4post":"1.9k","prev_post":{"title":"数据结构之栈 Stack 和队列 Queue","url":"/posts/3164/"},"next_post":{"title":"算法之基础","url":"/posts/2915/"},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"线性表 List\" href = \"#\"><span class=\"toc-number\">1.</span> <span class=\"toc-text\">线性表 List</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"线性表伪代码\" href = \"#\"><span class=\"toc-number\">2.</span> <span class=\"toc-text\">线性表伪代码 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"线性表的顺序存储结构\" href = \"#\"><span class=\"toc-number\">3.</span> <span class=\"toc-text\"> 线性表的顺序存储结构 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"顺序存储结构的地址计算方法\" href = \"#\"><span class=\"toc-number\">3.1.</span> <span class=\"toc-text\"> 顺序存储结构的地址计算方法 </span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"线性表的链式存储结构\" href = \"#\"><span class=\"toc-number\">4.</span> <span class=\"toc-text\">线性表的链式存储结构 </span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"单链表\" href = \"#\"><span class=\"toc-number\">4.1.</span> <span class=\"toc-text\"> 单链表 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"静态链表\" href = \"#\"><span class=\"toc-number\">4.2.</span> <span class=\"toc-text\">静态链表 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"循环链表\" href = \"#\"><span class=\"toc-number\">4.3.</span> <span class=\"toc-text\"> 循环链表 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" data-id=\"双向链表\" href = \"#\"><span class=\"toc-number\">4.4.</span> <span class=\"toc-text\"> 双向链表 </span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"找单链表中间的节点的方法\" href = \"#\"><span class=\"toc-number\">5.</span> <span class=\"toc-text\">找单链表中间的节点的方法 </span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" data-id=\"判断一个链表是否有环\" href = \"#\"><span class=\"toc-number\">6.</span> <span class=\"toc-text\">判断一个链表是否有环 </span></a></li></ol>","categories":[{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json","url":"/categories/数据结构与算法/"}],"tags":[{"name":"线性表","path":"api/tags/线性表.json","url":"/tags/线性表/"},{"name":"List","path":"api/tags/List.json","url":"/tags/List/"}]}